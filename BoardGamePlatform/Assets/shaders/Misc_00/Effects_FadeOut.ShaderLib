FILEVERSION = 2.4.0.0;
PLATFORM = DX9;

RENDER_STATE RSC_0 {
  blendingFromSurface = true;
  trackingmask = 1536;

  //------ Blend State Group ------
  alphatestref = 100;
  alphatestfunc = less_or_equal;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------
  cullmode = none;

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_1 {
  blendingFromSurface = true;
  trackingmask = 1;

  //------ Blend State Group ------
  alphatestref = 100;
  alphatestfunc = less_or_equal;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------
  cullmode = none;

  //------ Tesselation State Group ------
}

SHADER FadeOut_Simple {
  RenderStateContainerID = 0;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 17;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 1;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "Models\Textures\Star_03.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

#define USE_UV0


//- PERMUTATION MARKER -\\

#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#ifdef _VISION_DX11

cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4 fClipPlanes : packoffset(c12);
  float4    eyePos          : packoffset(c17);  // eye position
  float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
}

cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4  mMV   : packoffset(c0);   // model view matrix
  float4x4  mMVP  : packoffset(c4);   // model view projection matrix
  float4x4  mMW : packoffset(c8);   // model to worldspace matrix
  float4    LightmapScaleOfs : packoffset(c13);  // model UV to lightmap
}

cbuffer g_GlobalConstantBufferUser : register (b2)
{
  float4 LightPos : packoffset(c0);
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
    float4 RefPlaneX : packoffset(c1);
    float4 RefPlaneY : packoffset(c2);
    float4 RefPlaneW : packoffset(c3);
  #endif
}

#else

	float4x4 mMV : register(c0);
	float4x4 mMVP : register(c8);
	float4x4 mMW : register(c20);
	float3 eyePos : register(c31);

	float4 fClipPlanes : register(c24);

	#ifdef _VISION_PS3
	  float4 LightPos : register(c64);
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX : register(c66);
	    float4 RefPlaneY : register(c67);
	    float4 RefPlaneW : register(c68);
	  #endif
	#else
	  float4 LightPos;
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX;
	    float4 RefPlaneY;
	    float4 RefPlaneW;
	  #endif
	#endif

	float4 LightmapScaleOfs : register(c60);
	#ifdef USE_FOGCOORD
	float4 fogParamVS : register(c62);
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
float3 GetVectorInTextureSpace(float3 InVector, float3 Tangent, float3 Normal, float3 BiNormal)
{
  float3 OutVector;

  OutVector.x = dot (Tangent, InVector);
  OutVector.y = -dot (BiNormal, InVector);
  OutVector.z = dot (Normal, InVector);
  return OutVector;
}
#endif

struct VS_IN                   
{                              
  float3 ObjPos   : POSITION;
  float3 Normal : NORMAL;
  
  #ifdef USE_COLOR
  float4 Color : COLOR0;
  #endif  
  
  #ifdef USE_UV0
  float2 UV0 : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
  float2 UV1 : TEXCOORD1;
  #endif

#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
#endif
};                                           

struct VS_OUT                                 
{                           
#ifdef _VISION_DX11
	float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif

#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif

#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif

  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif

#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};                                             

VS_OUT vs_main( VS_IN In )                        
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
  float4 objectSpacePos = float4(In.ObjPos, 1.0f);
  float3 worldPos = mul(mMW, objectSpacePos);
  
  #ifdef USE_TANGENT
    float3 objectSpaceTangent = In.Tangent;
  #endif

  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos;
  #endif  
  
  Out.ProjPos = mul(mMVP, float4(In.ObjPos, 1.0f));  
  Out.ScreenPosition = float4(Out.ProjPos.xy, Out.ProjPos.z, Out.ProjPos.w);

#ifdef USE_UV0  
Out.UV0AND1.x = In.UV0.x;
Out.UV0AND1.y = In.UV0.y;
#endif
  
  #ifdef USE_COLOR
  Out.Color = In.Color;
  #endif
  
#ifdef USE_UV1  
Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
#endif
  
  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)mMW , objectSpaceNormal) );
  
#ifdef USE_TANGENT
  Out.Tangent = normalize( mul((float3x3)mMW , objectSpaceTangent) );
  float fMul = dot(objectSpaceTangent, objectSpaceTangent) - 2.0f;
  Out.BiTangent = normalize( cross(Out.Tangent, Out.Normal)*fMul );
#endif

#ifdef USE_FOGCOORD
  Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
#endif

#ifdef USE_LIGHT_WS
  Out.LightWS = LightPos.xyz - worldPos;
#endif

  #ifdef PERMUTATION_ProjPointLight
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS,RefPlaneW.xyz);
  #endif
  #ifdef PERMUTATION_SpotLight
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, float4(worldPos,1.0));
    Out.ProjTexCoord.y = dot(RefPlaneY, float4(worldPos,1.0));
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, float4(worldPos,1.0));
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
  float4 worldSpacePos = mul(mMW, float4(In.ObjPos, 1.0f));
  Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(eyePos-worldSpacePos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
  Out.EyeDirAndDepth.w = mul(mMV, float4(In.ObjPos, 1.0f)).z / fClipPlanes.y;  
  #endif

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

//- PERMUTATION MARKER -\\

#define USE_UV0

#ifdef PREVIEW
			
			texture Base_Texture; //TEX Models\Textures\Star_03.dds
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX11
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX Models\Textures\Star_03.dds
			#endif

			#endif







#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  float4 LightRadius; // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	  
    #ifndef DEFERRED_RENDERING
    float4 LightColor; // xyz: color with pre-multiplied light multiplier
    #else
	  float AlphaThreshold;
    #endif
    
    float  GlobalAmbientMultiplier;
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    depthFogCol     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

float4 LightmapMultiplier : register(c0);

#ifdef USE_FOGCOORD
float4 gFogColor : register(c1);
#endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

	#ifdef _VISION_PS3
	float4 MaterialParams : register(c32);
	float4 LightPos : register(c64);
	float4 LightColor:register(c33);
	float4 LightRadius:register(c34);
	#else
	float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
	float4 LightPos;
	float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	#endif

	#ifdef DEFERRED_RENDERING
	float4 AlphaThreshold : register(c34);
	float  GlobalAmbientMultiplier : register(c35);
	#undef USE_LIGHT_WS // for security only
	#endif

#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	struct LIGHT_RESULT_SPEC
	{
	  float4 diffuse;
	  float4 specular;
	};

	//Computes the lightgrid diffuse+specular for a worldspace normal
	LIGHT_RESULT_SPEC GetLightGridSpec_WS(float3 eyeDir, float3 normal, 
	                                      float4 Light0, float4 Light1, 
	                                      float4 Light2, float4 Light3, 
	                                      float4 Light4, float4 Light5, 
	                                      float specExp)
	{
	  LIGHT_RESULT_SPEC lsres;
	  
	  float3 w = normal*normal;
	  
	  float3 vHalfAngleX,vHalfAngleY,vHalfAngleZ;
	  float4 cDiffuseX,cDiffuseY,cDiffuseZ;
	  
	  if (normal.x>0.0f)
	  {
	    vHalfAngleX = eyeDir + float3(1,0,0);
	    cDiffuseX = Light0;
	  } 
	  else
	  {
	    vHalfAngleX = eyeDir - float3(1,0,0);
	    cDiffuseX = Light1;
	  }
	  
	  if (normal.y>0.0f)
	  {
	    vHalfAngleY = eyeDir + float3(0,1,0);
	    cDiffuseY = Light2;
	  } 
	  else
	  {
	    vHalfAngleY = eyeDir - float3(0,1,0);
	    cDiffuseY = Light3;
	  }
	  
	  if (normal.z>0.0f)
	  {
	    vHalfAngleZ = eyeDir + float3(0,0,1);
	    cDiffuseZ = Light4;
	  } 
	  else
	  {
	    vHalfAngleZ = eyeDir - float3(0,0,1);
	    cDiffuseZ = Light5;
	  }


	  //Compute the specular
	  float3 vSpec;
	  vSpec.x = dot(normalize(vHalfAngleX), normal);
	  vSpec.y = dot(normalize(vHalfAngleY), normal);
	  vSpec.z = dot(normalize(vHalfAngleZ), normal);
	  
	  vSpec = pow( max(vSpec, 0.0), specExp) ;
	  
	  cDiffuseX *= w.x;
	  cDiffuseY *= w.y;
	  cDiffuseZ *= w.z;
	  
	  lsres.diffuse  = cDiffuseX          +  cDiffuseY         + cDiffuseZ;
	  lsres.specular = cDiffuseX*vSpec.x  +  cDiffuseY*vSpec.y + cDiffuseZ*vSpec.z;

	  return lsres;
	}
	
	LIGHT_RESULT_SPEC ComputeDot3LightmapLightingSpec(float3 normal, float3 lightDir, float3 eyeDir, float4 lightContrib, float specExp)
	{
	  LIGHT_RESULT_SPEC Out;
	  float fDot, fSDot;
	  float3 halfAngle;
	  fDot = max(dot(normal, lightDir) , 0.0);
	  Out.diffuse = lightContrib * fDot;
	  halfAngle = normalize(eyeDir + lightDir);
	  fSDot = dot(halfAngle, normal);
	  fSDot = pow(max(fSDot,0.0), specExp);
	  Out.specular = lightContrib * fSDot * fDot;
	  return Out;
	}	
	
	//Note: HalfAngle and Normal should be in the same space
	float GetSpecularIlluminationPoint(float3 HalfAngle, float3 Normal, float Exp)
	{
	    float SpecProd;
	    float3 nrmHalfAngleVec = normalize(HalfAngle);
	    SpecProd = dot(nrmHalfAngleVec, Normal);
	    SpecProd = pow(SpecProd, Exp);
	    return SpecProd;
	}	

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = res.diffuse*DiffuseColor;
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		
		result += res.specular*SpecMul;
		
		result.a = Opacity;
		
		return result;
	}
	
	#ifdef PERMUTATION_PointLight
	
	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
	{
	
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#endif

  
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		
		float DotProd = saturate(dot(NormLightVec, Normal));
		
    	float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));		
	
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_LightmapDot3
	
	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
	{
		const float3 vLightDir1 = float3(-0.816497, -0.000000, 0.577350);
		const float3 vLightDir2 = float3(0.408248,  -0.707107, 0.577350);
		const float3 vLightDir3 = float3(0.408248,   0.707107, 0.577350);
		
		#ifdef _VISION_DX11
		float4 cLightmap1 = Lightmap1.Sample(Lightmap1_Sampler, LightmapCoord);
		float4 cLightmap2 = Lightmap2.Sample(Lightmap2_Sampler, LightmapCoord);
		float4 cLightmap3 = Lightmap3.Sample(Lightmap3_Sampler, LightmapCoord);
		#else
		float4 cLightmap1 = tex2D(Lightmap1, LightmapCoord);
		float4 cLightmap2 = tex2D(Lightmap2, LightmapCoord);
		float4 cLightmap3 = tex2D(Lightmap3, LightmapCoord);
		#endif
		
		LIGHT_RESULT_SPEC lsres;
		LIGHT_RESULT_SPEC difspec;

		difspec = ComputeDot3LightmapLightingSpec(Normal, vLightDir1, EyeDir, cLightmap1, SpecularExponent);

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir2, EyeDir, cLightmap2, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir3, EyeDir, cLightmap3, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		float4 cResColor = difspec.diffuse*DiffuseColor*LightmapMultiplier.x;
 
		//modulate the specular lighting (either by color or float)
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		cResColor += difspec.specular*SpecMul;
		cResColor.a = Opacity;
		
		return cResColor;
	}
	
	#endif
	
	#ifdef PERMUTATION_SpotLight
	
	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif
		
		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjTexCoord / ProjTexCoord.w); //2D spotlight projector
		#else
		float4 ProjLightCol = LightColor*tex2Dproj(ProjTex, ProjTexCoord); //2D spotlight projector
		#endif

		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		   
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
	
		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
		ResColor*=saturate(sign(ProjTexCoord.w));
		
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_ProjPointLight

	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif

		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjDir); // Cubemap projector
		#else
		float4 ProjLightCol = LightColor*texCUBE(ProjTex, ProjDir); // Cubemap projector
		#endif
		
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
	
		return float4(ResColor.rgb, Opacity);	
	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING

struct PixelDataPacked
{
  float4 Accumulation;
  float4 Diffuse;
  float4 Normal;
  float4 DepthSpec;
};

struct PixelDataUnpacked
{
  float3 vAccInitial;
  float fDepth;
  float3 vNormal;
  float3 vDiffColor;
  float3 vSpecColor;
  float fSpecExp;
};



#ifdef _VISION_XENON

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.125f, ip);
  uncompressedComponents.g = modf(ip * 0.125f, ip);
  uncompressedComponents.r = ip * 0.125f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 7.0f);
  return truncated.r * 64.f + truncated.g * 8.f + truncated.b;
}

#else

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.0625f, ip);
  uncompressedComponents.g = modf(ip * 0.0625f, ip);
  uncompressedComponents.r = ip * 0.0625f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 15.0f);
  return truncated.r * 256.f + truncated.g * 16.f + truncated.b;
}

#endif

struct DEFERRED_OUT
{
#ifdef _VISION_DX11
  float4 Accumulation : SV_Target0;
  float4 Diffuse : SV_Target1;
  float4 Normal : SV_Target2;
  float4 DepthSpec : SV_Target3;

#else
  float4 Accumulation : COLOR0;
  float4 Diffuse : COLOR1;
  float4 Normal : COLOR2;
  float4 DepthSpec : COLOR3;
 #endif
};

inline DEFERRED_OUT packPixelValues(PixelDataUnpacked pixelData)
{
  DEFERRED_OUT Out;
  Out.Accumulation = float4(pixelData.vAccInitial, 1.0f);
  Out.Diffuse = float4(pixelData.vDiffColor, pixelData.fSpecExp);
  Out.Normal = float4(pixelData.vNormal*0.5f + 0.5f, 1.0f);
  #ifdef _VISION_PS3
    float temp = pack_2half(half2(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor)));
    Out.DepthSpec = unpack_4ubyte(temp);
    //Out.DepthSpec.xy = packNormalizedFloatInTwoBytes(pixelData.fDepth);
    //Out.DepthSpec.zw = float2(0.0f, 0.0f);
  #else
    #ifdef SPECULAR_COLOR_MONO
      Out.DepthSpec = float4(pixelData.fDepth, (pixelData.vSpecColor.x + pixelData.vSpecColor.y + pixelData.vSpecColor.z) * 0.33333f, 0.0f, 0.0f);
    #else    
      Out.DepthSpec = float4(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor), 0.0f, 0.0f);
    #endif
  #endif
  return Out;
}


inline PixelDataUnpacked unpackPixelValues(PixelDataPacked packedPixelData)
{
  PixelDataUnpacked unpackedPixel;
  unpackedPixel.vAccInitial = packedPixelData.Accumulation.xyz;
  unpackedPixel.fDepth = packedPixelData.DepthSpec.x;
  unpackedPixel.vNormal = (packedPixelData.Normal.xyz*2.0f) - 1.0f;
  unpackedPixel.vDiffColor = packedPixelData.Diffuse.xyz;
  #ifdef SPECULAR_COLOR_MONO
    unpackedPixel.vSpecColor = packedPixelData.DepthSpec.yyy;
  #else
    unpackedPixel.vSpecColor = expandFloatToFloat3_16Bits(packedPixelData.DepthSpec.y);
  #endif
  unpackedPixel.fSpecExp = packedPixelData.Diffuse.w;
  return unpackedPixel;
}


inline float3 positionForDepth(float fDepth, float3 vEyePos, float3 vViewDir)
{
  float3 vRes = vEyePos + fDepth * vViewDir;
  return vRes;
}

#endif


struct PS_IN
{
#ifdef _VISION_DX11
  float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif
  
#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif
  
#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif
  
  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif


#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};

#ifdef DEFERRED_RENDERING
	DEFERRED_OUT ps_main( PS_IN In )
#else
	#ifdef _VISION_DX11
	float4 ps_main( PS_IN In ) : SV_Target
	#else
	float4 ps_main( PS_IN In ) : COLOR
	#endif
#endif
{
 
  #ifdef USE_FOGCOORD
	float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
  #endif
  
  #ifdef PREVIEW
			float4 VAR_beb5a26bf6894324b3b720175eae332d = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else
			
			#ifdef _VISION_DX11
			float4 VAR_beb5a26bf6894324b3b720175eae332d = BaseTexture.Sample( BaseTexture_Sampler, In.UV0AND1.xy );
			#else
			float4 VAR_beb5a26bf6894324b3b720175eae332d = tex2D( BaseTexture, In.UV0AND1.xy );
			#endif
			#endif
/*!float
VAR_beb5a26bf6894324b3b720175eae332d.r
*/
/*!float
VAR_beb5a26bf6894324b3b720175eae332d.g
*/
/*!float
VAR_beb5a26bf6894324b3b720175eae332d.b
*/
/*!float
VAR_beb5a26bf6894324b3b720175eae332d.a
*/
/*!float4
VAR_beb5a26bf6894324b3b720175eae332d
*/
//! MARKER - 2d8b9edf279b4b75b99985f3281858ec
float VAR_c797003c60694dbdb420a3b7f5eb99af = gTime.x;
/*!float
VAR_c797003c60694dbdb420a3b7f5eb99af
*/
//! MARKER - b76167cc4cf544959d708a66c0fa5cda
float VAR_14057341f85d47acb2a8e332d9b81268 = sin( VAR_c797003c60694dbdb420a3b7f5eb99af );
/*!float
VAR_14057341f85d47acb2a8e332d9b81268
*/
//! MARKER - f38107f659e34f51af3bb51a958423e4
float VAR_0916b42e04cf433bbb50807cc5e8a1a3 = (VAR_beb5a26bf6894324b3b720175eae332d.a * VAR_14057341f85d47acb2a8e332d9b81268);
/*!float
VAR_0916b42e04cf433bbb50807cc5e8a1a3
*/
//! MARKER - 8af74baba5c24939a4cfa6aa8f5a2d22
float4 VAR_73464cc535294d299ad64b0b0172626d = float4( VAR_beb5a26bf6894324b3b720175eae332d.r, VAR_beb5a26bf6894324b3b720175eae332d.g, VAR_beb5a26bf6894324b3b720175eae332d.b, VAR_0916b42e04cf433bbb50807cc5e8a1a3 );
/*!float4
VAR_73464cc535294d299ad64b0b0172626d
*/
//! MARKER - 7622e6b5479842d98c4254c769b37393
return VAR_73464cc535294d299ad64b0b0172626d;
//! MARKER - 864fb4e331f445c1bfa6fe6c281059de


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER FadeOut_Advanced {
  RenderStateContainerID = 1;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 1;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "Models\Textures\Star_03.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0


//- PERMUTATION MARKER -\\

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

//- PERMUTATION MARKER -\\

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0





#ifdef PREVIEW
			
			texture Base_Texture; //TEX Models\Textures\Star_03.dds
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX Models\Textures\Star_03.dds
			#endif

			#endif











#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  
/*!float
0.5
*/
//! MARKER - c54cfa38b3654eb194dfd32a75acbefe

/*!float
1
*/
//! MARKER - a5c059cd9e2b490a83835c899ee59b75

/*!float
1
*/
//! MARKER - ddb119d9f4e94695a1549c48dc1fd8fa
float VAR_UVRotator_e37c69ef83c6452e8a0cbdff3041c31d = sin( 1 * gTime.x );
			float VAR_UVRotator_64ff49ef89414dc5be45d5566bf96003 = cos( 1 * gTime.x );
			float2 VAR_UVRotator_80aedb8cda734472bab648c3a4fd4630 = float2( ((In.UV0AND1.xy.x-0.5) * VAR_UVRotator_64ff49ef89414dc5be45d5566bf96003) - ((In.UV0AND1.xy.y-0.5) * VAR_UVRotator_e37c69ef83c6452e8a0cbdff3041c31d), ((In.UV0AND1.xy.y-0.5) * VAR_UVRotator_64ff49ef89414dc5be45d5566bf96003) + ((In.UV0AND1.xy.x-0.5) * VAR_UVRotator_e37c69ef83c6452e8a0cbdff3041c31d) ) + float2( 0.5, 0.5 );
/*!float2
VAR_UVRotator_80aedb8cda734472bab648c3a4fd4630
*/
//! MARKER - bbc0e2b959e24300ad5cf4852156e49e
#ifdef PREVIEW
			float4 VAR_BaseTexture_da71006ea90c453fadfaf92c5d704e79 = tex2D( BaseTexture_Sampler, VAR_UVRotator_80aedb8cda734472bab648c3a4fd4630 );
			#else			
			float4 VAR_BaseTexture_da71006ea90c453fadfaf92c5d704e79 = vTex2D( BaseTexture, BaseTexture_Sampler, VAR_UVRotator_80aedb8cda734472bab648c3a4fd4630 );
			#endif
/*!float
VAR_BaseTexture_da71006ea90c453fadfaf92c5d704e79.r
*/
/*!float
VAR_BaseTexture_da71006ea90c453fadfaf92c5d704e79.g
*/
/*!float
VAR_BaseTexture_da71006ea90c453fadfaf92c5d704e79.b
*/
/*!float
VAR_BaseTexture_da71006ea90c453fadfaf92c5d704e79.a
*/
/*!float4
VAR_BaseTexture_da71006ea90c453fadfaf92c5d704e79
*/
//! MARKER - 48fa82fb15224cbda7d364c50b492345
float VAR_Time_97bf08a7eedf42169a54deaf04476115 = gTime.x * 1.0;
/*!float
VAR_Time_97bf08a7eedf42169a54deaf04476115
*/
//! MARKER - b980927166bb4b53835efd40b1d7b9b7

/*!float
2
*/
//! MARKER - 34c926fc7183488e9cfd9ff690ecb759
float VAR_Multiply_b0a4a98cd88940f2aed617aae82b8330 = (VAR_Time_97bf08a7eedf42169a54deaf04476115 * 2);
/*!float
VAR_Multiply_b0a4a98cd88940f2aed617aae82b8330
*/
//! MARKER - 8115afa8a09c4410a8353f319ba63186
float VAR_Sine_2b9d0950dedf4a37b86801c057ae5446 = sin( VAR_Multiply_b0a4a98cd88940f2aed617aae82b8330 );
/*!float
VAR_Sine_2b9d0950dedf4a37b86801c057ae5446
*/
//! MARKER - 2bc2c5d47cb746c99f73bf8bdf587184
float VAR_Add_e5ea2fc515ae408fbe591d292e60b6d6 = (VAR_Sine_2b9d0950dedf4a37b86801c057ae5446 + 1);
/*!float
VAR_Add_e5ea2fc515ae408fbe591d292e60b6d6
*/
//! MARKER - dc6110129418476895f3d10c262aa2a9
float VAR_Multiply_5d21669e741b4ff0b7f782f7c7ae9835 = (VAR_Add_e5ea2fc515ae408fbe591d292e60b6d6 * 0.5);
/*!float
VAR_Multiply_5d21669e741b4ff0b7f782f7c7ae9835
*/
//! MARKER - 0330bb8a675448afb722214aeaaf4148
float VAR_Multiply_8c7b15049f0041fb8fccd2e50acb439f = (VAR_BaseTexture_da71006ea90c453fadfaf92c5d704e79.a * VAR_Multiply_5d21669e741b4ff0b7f782f7c7ae9835);
/*!float
VAR_Multiply_8c7b15049f0041fb8fccd2e50acb439f
*/
//! MARKER - 84ca9ccf7d69467e942f5797a6576c22
float4 VAR_VectorAssembler_d3a2948d5abd450399fca44dd6506313 = float4( VAR_BaseTexture_da71006ea90c453fadfaf92c5d704e79.r, 0.0, VAR_Multiply_5d21669e741b4ff0b7f782f7c7ae9835, VAR_Multiply_8c7b15049f0041fb8fccd2e50acb439f );
/*!float4
VAR_VectorAssembler_d3a2948d5abd450399fca44dd6506313
*/
//! MARKER - 1616b2fc0a0840b7a526b0248826bb77
return VAR_VectorAssembler_d3a2948d5abd450399fca44dd6506313;
//! MARKER - fa98b583107647b694cb422c44152eed


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

//////////////////////////////////////////////////////////////////////////////

EFFECT FadeOut_Simple {
  DESCRIPTION = {};
  TECHNIQUE "FadeOut_Simple"
  {
    passes="FadeOut_Simple";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT FadeOut_Advanced {
  DESCRIPTION = {};
  TECHNIQUE "FadeOut_Advanced"
  {
    passes="FadeOut_Advanced";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

