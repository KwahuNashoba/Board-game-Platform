FILEVERSION = 2.4.0.0;
PLATFORM = DX9;

//////////////////////////////////////////////////////////////////////////////
SOURCECODE=$SOURCECODETAG{
// [This is mandatory comment line; Place your comment here.]
  }$SOURCECODETAG

//////////////////////////////////////////////////////////////////////////////

RENDER_STATE RSC_0 {
  trackingmask = 1;

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;
  dstblend = one_minus_src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_1 {
  trackingmask = 1;

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_2 {
  trackingmask = 1;

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_3 {
  trackingmask = 1;

  //------ Blend State Group ------
  separateAlphaBlend = true;
  alphatocoverage = true;
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;
  dstblend = one_minus_src_alpha;
  srcblendAlpha = src_alpha;
  dstblendAlpha = one_minus_src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_4 {
  trackingmask = 1;

  //------ Blend State Group ------
  alphatestref = 64;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

SHADER scroller_left.forward {
  RenderStateContainerID = 0;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0


//- PERMUTATION MARKER -\\

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

//- PERMUTATION MARKER -\\

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0


#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif



#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  // use another fragment for preview purposes
			#ifdef PREVIEW
			float2 VAR_UVscroller_44bbf9d7470045e0a19a301a2dd596e4 = frac(In.UV0AND1.xy + float2((-1.0 * -0.5 * gTime.x), (-1.0 * 0 * gTime.x)));
			#else
			float2 VAR_UVscroller_44bbf9d7470045e0a19a301a2dd596e4 = In.UV0AND1.xy + float2((-1.0 * -0.5 * gTime.x), (-1.0 * 0 * gTime.x));
			#endif
/*!float2
VAR_UVscroller_44bbf9d7470045e0a19a301a2dd596e4
*/
//! MARKER - d4adffd127364d808d367a41091bacd0
#ifdef PREVIEW
			float4 VAR_BaseTexture_84fd862354c647a98fedcefa9dd7c9c4 = tex2D( BaseTexture_Sampler, VAR_UVscroller_44bbf9d7470045e0a19a301a2dd596e4 );
			#else			
			float4 VAR_BaseTexture_84fd862354c647a98fedcefa9dd7c9c4 = vTex2D( BaseTexture, BaseTexture_Sampler, VAR_UVscroller_44bbf9d7470045e0a19a301a2dd596e4 );
			#endif
/*!float
VAR_BaseTexture_84fd862354c647a98fedcefa9dd7c9c4.r
*/
/*!float
VAR_BaseTexture_84fd862354c647a98fedcefa9dd7c9c4.g
*/
/*!float
VAR_BaseTexture_84fd862354c647a98fedcefa9dd7c9c4.b
*/
/*!float
VAR_BaseTexture_84fd862354c647a98fedcefa9dd7c9c4.a
*/
/*!float4
VAR_BaseTexture_84fd862354c647a98fedcefa9dd7c9c4
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07
return VAR_BaseTexture_84fd862354c647a98fedcefa9dd7c9c4;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER scroller_right.forward {
  RenderStateContainerID = 1;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0


//- PERMUTATION MARKER -\\

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

//- PERMUTATION MARKER -\\

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0


#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif



#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  // use another fragment for preview purposes
			#ifdef PREVIEW
			float2 VAR_UVscroller_cb85689e452f4b709ec957ef56eb2596 = frac(In.UV0AND1.xy + float2((-1.0 * 0.5 * gTime.x), (-1.0 * 0 * gTime.x)));
			#else
			float2 VAR_UVscroller_cb85689e452f4b709ec957ef56eb2596 = In.UV0AND1.xy + float2((-1.0 * 0.5 * gTime.x), (-1.0 * 0 * gTime.x));
			#endif
/*!float2
VAR_UVscroller_cb85689e452f4b709ec957ef56eb2596
*/
//! MARKER - 611b3a8ef66f4c60b251af27956e9982
#ifdef PREVIEW
			float4 VAR_BaseTexture_e440531350a8486a9c86b51a3235fad3 = tex2D( BaseTexture_Sampler, VAR_UVscroller_cb85689e452f4b709ec957ef56eb2596 );
			#else			
			float4 VAR_BaseTexture_e440531350a8486a9c86b51a3235fad3 = vTex2D( BaseTexture, BaseTexture_Sampler, VAR_UVscroller_cb85689e452f4b709ec957ef56eb2596 );
			#endif
/*!float
VAR_BaseTexture_e440531350a8486a9c86b51a3235fad3.r
*/
/*!float
VAR_BaseTexture_e440531350a8486a9c86b51a3235fad3.g
*/
/*!float
VAR_BaseTexture_e440531350a8486a9c86b51a3235fad3.b
*/
/*!float
VAR_BaseTexture_e440531350a8486a9c86b51a3235fad3.a
*/
/*!float4
VAR_BaseTexture_e440531350a8486a9c86b51a3235fad3
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07
return VAR_BaseTexture_e440531350a8486a9c86b51a3235fad3;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER scroller_swirl.forward {
  RenderStateContainerID = 2;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0


//- PERMUTATION MARKER -\\

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

//- PERMUTATION MARKER -\\

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0


#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif



#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  // use another fragment for preview purposes
			#ifdef PREVIEW
			float2 VAR_UVscroller_c9c4d0e119c34689952d710d64982fde = frac(In.UV0AND1.xy + float2((-1.0 * 0.785 * gTime.x), (-1.0 * 0 * gTime.x)));
			#else
			float2 VAR_UVscroller_c9c4d0e119c34689952d710d64982fde = In.UV0AND1.xy + float2((-1.0 * 0.785 * gTime.x), (-1.0 * 0 * gTime.x));
			#endif
/*!float2
VAR_UVscroller_c9c4d0e119c34689952d710d64982fde
*/
//! MARKER - cb121a2b4bc64340bd54a0b2ec9b56c6
#ifdef PREVIEW
			float4 VAR_BaseTexture_183f700e30e141e4879c5c2b450e3a76 = tex2D( BaseTexture_Sampler, VAR_UVscroller_c9c4d0e119c34689952d710d64982fde );
			#else			
			float4 VAR_BaseTexture_183f700e30e141e4879c5c2b450e3a76 = vTex2D( BaseTexture, BaseTexture_Sampler, VAR_UVscroller_c9c4d0e119c34689952d710d64982fde );
			#endif
/*!float
VAR_BaseTexture_183f700e30e141e4879c5c2b450e3a76.r
*/
/*!float
VAR_BaseTexture_183f700e30e141e4879c5c2b450e3a76.g
*/
/*!float
VAR_BaseTexture_183f700e30e141e4879c5c2b450e3a76.b
*/
/*!float
VAR_BaseTexture_183f700e30e141e4879c5c2b450e3a76.a
*/
/*!float4
VAR_BaseTexture_183f700e30e141e4879c5c2b450e3a76
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07
return VAR_BaseTexture_183f700e30e141e4879c5c2b450e3a76;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER FieldHighlight {
  RenderStateContainerID = 3;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0


//- PERMUTATION MARKER -\\

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

//- PERMUTATION MARKER -\\

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0




#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif











#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  
/*!float
2
*/
//! MARKER - 1cbaa0c801eb4eeeb48292c442f2d6a6

/*!float
0.3
*/
//! MARKER - 677648f643bb4dfca71242b33b263473
float VAR_Time_8c87a24340be443c823608e993670ddc = gTime.x * 2;
/*!float
VAR_Time_8c87a24340be443c823608e993670ddc
*/
//! MARKER - 55d000d1e2bc4c3f98508b052b4fcbee
#ifdef PREVIEW
			float4 VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961.r
*/
/*!float
VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961.g
*/
/*!float
VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961.b
*/
/*!float
VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961.a
*/
/*!float4
VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
-0.5
*/
//! MARKER - b0f78ef826cb470b9f402248e47cb212
float VAR_Sine_584ea14077a34566b77f384438a75168 = sin( VAR_Time_8c87a24340be443c823608e993670ddc );
/*!float
VAR_Sine_584ea14077a34566b77f384438a75168
*/
//! MARKER - 2615d59240e04b29aa113c0cb72ef51f
float VAR_Abs_60814e32ab7846af81cafe73fcceed82 = abs( VAR_Sine_584ea14077a34566b77f384438a75168 );
/*!float
VAR_Abs_60814e32ab7846af81cafe73fcceed82
*/
//! MARKER - 942cb5c5f4b04a3e8e6843e9236a447a
float VAR_Multiply_e183bf53f0c14736b416d461d1b85f3f = (VAR_Abs_60814e32ab7846af81cafe73fcceed82 * -0.5);
/*!float
VAR_Multiply_e183bf53f0c14736b416d461d1b85f3f
*/
//! MARKER - 1e837277b85f4de4bd0a6045eb725141
float VAR_Multiply_f03668541ea747a8be40023a17043e31 = (0.3 * VAR_Abs_60814e32ab7846af81cafe73fcceed82);
/*!float
VAR_Multiply_f03668541ea747a8be40023a17043e31
*/
//! MARKER - 4d3c526ad09c48589bad0a571ae5a8af
float VAR_Add_ba62e0dc4ca24a589f6f94a618dca7a1 = (VAR_Multiply_f03668541ea747a8be40023a17043e31 + VAR_Multiply_e183bf53f0c14736b416d461d1b85f3f);
/*!float
VAR_Add_ba62e0dc4ca24a589f6f94a618dca7a1
*/
//! MARKER - 03a7eef2be5f4fa1a99a2bc4acb0322a
float VAR_Add_d9e1efc8ceee4e4187370c05d59c7318 = (VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961.a + VAR_Add_ba62e0dc4ca24a589f6f94a618dca7a1);
/*!float
VAR_Add_d9e1efc8ceee4e4187370c05d59c7318
*/
//! MARKER - 84a42a999c77487fa5b38f3ac0e35ed0
float4 VAR_VectorAssembler_0cee1a4f93a7491ba2380349e8a8978b = float4( VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961.r, VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961.g, VAR_BaseTexture_e6ebd31b0dc249ab83cdcf3f7c6fb961.b, VAR_Add_d9e1efc8ceee4e4187370c05d59c7318 );
/*!float4
VAR_VectorAssembler_0cee1a4f93a7491ba2380349e8a8978b
*/
//! MARKER - eac2daa0c3b643d6b7256799ead86478
return VAR_VectorAssembler_0cee1a4f93a7491ba2380349e8a8978b;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER scroller_crown_.forward {
  RenderStateContainerID = 4;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 17;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "Particles\spirit_trails_landscape.tga";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0


//- PERMUTATION MARKER -\\

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

//- PERMUTATION MARKER -\\

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0











#ifdef PREVIEW
			
			texture Base_Texture; //TEX Particles\spirit_trails_landscape.tga
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX Particles\spirit_trails_landscape.tga
			#endif

			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  // use another fragment for preview purposes
			#ifdef PREVIEW
			float2 VAR_UVscroller_a8f68b2416db47dca4122622670764cb = frac(In.UV0AND1.xy + float2((-1.0 * -0.5 * gTime.x), (-1.0 * 0 * gTime.x)));
			#else
			float2 VAR_UVscroller_a8f68b2416db47dca4122622670764cb = In.UV0AND1.xy + float2((-1.0 * -0.5 * gTime.x), (-1.0 * 0 * gTime.x));
			#endif
/*!float2
VAR_UVscroller_a8f68b2416db47dca4122622670764cb
*/
//! MARKER - 48f15c6bf235434cbce94436fa0bae3b
float VAR_Time_f17817c0d8694bec9edee60d9e0790b2 = gTime.x * 1.0;
/*!float
VAR_Time_f17817c0d8694bec9edee60d9e0790b2
*/
//! MARKER - 8109da1673404a70a0fec9fad440eb30
float VAR_Sine_a5655dd67fa84db0972805a2ac558294 = sin( VAR_Time_f17817c0d8694bec9edee60d9e0790b2 );
/*!float
VAR_Sine_a5655dd67fa84db0972805a2ac558294
*/
//! MARKER - dc0e385822284d828dbe98e2d013a478

/*!float
0.3
*/
//! MARKER - b4e8eedb61344e688f4934c17344ab60

/*!float
-0.15
*/
//! MARKER - c50cc29742a04f608d98e69b1d456b0c
float VAR_Abs_4cf618386068419a8e1f51368fd1f6cd = abs( VAR_Sine_a5655dd67fa84db0972805a2ac558294 );
/*!float
VAR_Abs_4cf618386068419a8e1f51368fd1f6cd
*/
//! MARKER - 0b78b66421ec409ba0196e183364b0a7
float VAR_Multiply_62622eb19a52484e9f19f3279f1ee008 = (0.3 * VAR_Abs_4cf618386068419a8e1f51368fd1f6cd);
/*!float
VAR_Multiply_62622eb19a52484e9f19f3279f1ee008
*/
//! MARKER - 50bfeb6bc2754622ad51d09bc68e5e17
float VAR_Multiply_592927017e8d4b77b05d6eead54d907a = (VAR_Abs_4cf618386068419a8e1f51368fd1f6cd * -0.15);
/*!float
VAR_Multiply_592927017e8d4b77b05d6eead54d907a
*/
//! MARKER - 15e22cf27fb54a49afe6c8d2a5d61f90
float VAR_Add_d41a5b559aa54b548c31030c0a231939 = (VAR_Multiply_62622eb19a52484e9f19f3279f1ee008 + VAR_Multiply_592927017e8d4b77b05d6eead54d907a);
/*!float
VAR_Add_d41a5b559aa54b548c31030c0a231939
*/
//! MARKER - 4b72b8c007154cde872ef1c8c4bb6ddf
float2 VAR_Add_0b2e5e4e5b0c4f338ef3415561685f58 = (VAR_UVscroller_a8f68b2416db47dca4122622670764cb + VAR_Add_d41a5b559aa54b548c31030c0a231939);
/*!float2
VAR_Add_0b2e5e4e5b0c4f338ef3415561685f58
*/
//! MARKER - 6acf65c4c2494aafa390bce62c8e2c4b
#ifdef PREVIEW
			float4 VAR_BaseTexture_c80673b933b4469a83487f7d333febea = tex2D( BaseTexture_Sampler, VAR_Add_0b2e5e4e5b0c4f338ef3415561685f58 );
			#else			
			float4 VAR_BaseTexture_c80673b933b4469a83487f7d333febea = vTex2D( BaseTexture, BaseTexture_Sampler, VAR_Add_0b2e5e4e5b0c4f338ef3415561685f58 );
			#endif
/*!float
VAR_BaseTexture_c80673b933b4469a83487f7d333febea.r
*/
/*!float
VAR_BaseTexture_c80673b933b4469a83487f7d333febea.g
*/
/*!float
VAR_BaseTexture_c80673b933b4469a83487f7d333febea.b
*/
/*!float
VAR_BaseTexture_c80673b933b4469a83487f7d333febea.a
*/
/*!float4
VAR_BaseTexture_c80673b933b4469a83487f7d333febea
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07
float4 VAR_VectorAssembler_c6116980ab1848c982dad9c7ae9be48e = float4( VAR_BaseTexture_c80673b933b4469a83487f7d333febea.r, VAR_BaseTexture_c80673b933b4469a83487f7d333febea.g, VAR_BaseTexture_c80673b933b4469a83487f7d333febea.b, VAR_BaseTexture_c80673b933b4469a83487f7d333febea.a );
/*!float4
VAR_VectorAssembler_c6116980ab1848c982dad9c7ae9be48e
*/
//! MARKER - a60d53ae4f2b4fa48284b99a34a0fa28
return VAR_VectorAssembler_c6116980ab1848c982dad9c7ae9be48e;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

//////////////////////////////////////////////////////////////////////////////

EFFECT scroller_left.forward {
  DESCRIPTION = {};
  TECHNIQUE "scroller_left.forward"
  {
    passes="scroller_left.forward";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT scroller_right.forward {
  DESCRIPTION = {};
  TECHNIQUE "scroller_right.forward"
  {
    passes="scroller_right.forward";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT scroller_swirl.forward {
  DESCRIPTION = {};
  TECHNIQUE "scroller_swirl.forward"
  {
    passes="scroller_swirl.forward";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT FieldHighlight {
  DESCRIPTION = {};
  TECHNIQUE "FieldHighlight"
  {
    passes="FieldHighlight";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT scroller_crown_.forward {
  DESCRIPTION = {};
  TECHNIQUE "scroller_crown_.forward"
  {
    passes="scroller_crown_.forward";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

